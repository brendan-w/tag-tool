#!/usr/bin/env python3

import os
import sys
import subprocess
from collections import namedtuple

from tagtool import Filename, get_config
from tagtool.utils import empty_links_dir



help_text = """
Usage:
\ttag-find [OPTION...] [SELECTOR...]

Selectors:
\t[TAG]    filters tagged files for this tag         ("AND")
\t+[TAG]   adds tagged files to the selection        ("OR")
\t-[TAG]   removes tagged files from the selection   ("NOT")

Options:
\t--nocase   performs a case insensitive search
\t--help    prints this help text and exits

For issues and documentation: https://github.com/brendan-w/tag-tool
"""



# Tag operation struct with slots for the tag (string) and the
# operation type (see below)
Operation = namedtuple('TagOp', 'tag type')

# available operations
INTERSECTION = 0
INCLUSION    = 1
EXCLUSION    = 2




# constructs a find command based on the operations given
# Note: The result of this command will contain several falsely selected
# files, since it will also match substrings of tags.
def build_command(operations, config):

    find_flags = ""

    # chooses one of the following:
    # -name -iname -path -ipath
    flag = " -"
    flag += "i" if not config["case_sensitive"] else ""
    flag += "path" if config["use_dirs"] else "name"

    for op in operations:
        if op.type == INCLUSION:
            if not find_flags:
                find_flags += " %s *%s*" % (flag, op.tag)
            else:
                find_flags = "( " + find_flags + " ) -o %s *%s*" % (flag, op.tag)
        elif op.type == EXCLUSION:
            find_flags += " ! %s *%s*" % (flag, op.tag)
        elif op.type == INTERSECTION:
            find_flags += " %s *%s*" % (flag, op.tag)

    # insert the selection flags into the main find command

    #                 root_dir          find_flags
    find_cmd = ["find"]
    find_cmd += [config["root_dir"]]
    find_cmd += ["-type", "f"]
    find_cmd += find_flags.split()
    find_cmd += ["!", "(", "-path", "*/.*", "-perm", "-o=x", ")"]

    return find_cmd


# function that uses `find` to retrieve a basic list of files matching
# the given tag selectors.
# Note: see note for build_command()
def find_base_files(operations, config):

    cmd = build_command(operations, config)

    # run the find
    try:
        b = subprocess.check_output(cmd, universal_newlines=True)
        return b.splitlines()
    except subprocess.CalledProcessError:
        print("Failed to execute 'find'")
        return []


# function to refine the selection based on the users instructions
# returns boolean for whether the file was selected
def match(filestr, operations, config):

    f = Filename(filestr, config)

    matched = True

    # unfortunately, we can't bail on the first unmatched operation
    # since the file can always be included later with `+[TAG]`
    for op in operations:

        if op.type == INTERSECTION:
            if not f.has_tag(op.tag):
                matched = False
        else:
            # if the file has the tag for this operation
            if f.has_tag(op.tag):
                if op.type == INCLUSION:
                    matched = True
                elif op.type == EXCLUSION:
                    matched = False

    return matched


# main selector function
# runs a `find` command and then refines the search with tag matching
def select(operations, config):
    base_files = find_base_files(operations, config)
    return [f for f in base_files if match(f, operations, config)]


def main():
    operations = []
    symlink = False

    # config params that will override the .tagdir params
    overrides = {}

    for option in sys.argv[1:]:
        if option == "--help":
            print(help_text)
            return
        elif option == "--symlink":
            symlink = True
        elif option == "--nocase":
            overrides["case_sensitive"] = False
        else:
            if option[0] == "+":
                operations.append(Operation(option[1:], INCLUSION))
            elif option[0] == "-":
                operations.append(Operation(option[1:], EXCLUSION))
            else:
                operations.append(Operation(option, INTERSECTION))

    # check that the user entered something
    if len(operations) == 0:
        print("please give tag selectors")
        return

    # check for delimeters in the tags
    # if not all([ valid_tag(op.tag) for op in operations ]):
    #     print("tags cannot be empty strings, or contain delimeters")
    #     return

    # run the selection
    config = get_config(overrides=overrides)
    files = select(operations, config)

    if not symlink:
        for f in files:
            print(f)
    else:
        # empty the tmp directory
        os.makedirs(config["symlink_dir"], exist_ok=True)
        empty_links_dir(config["symlink_dir"])
        for f in files:
            # construct a pretty filename out of the original file's path
            name = os.path.relpath(f, config["root_dir"])
            name = name.replace("/", "-")
            os.symlink(f, os.path.join(config["symlink_dir"], name))

        print("Symlinked %d files" % len(files))


if(__name__ == "__main__"):
    main()
