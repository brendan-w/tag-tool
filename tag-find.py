#!/usr/bin/env python3

import re
import sys
import subprocess
from utils import *
from collections import namedtuple

Operation = namedtuple('TagOp', 'tag type')

# available operations
INTERSECTION = 0
INCLUSION    = 1
EXCLUSION    = 2



help_text = """
Usage:
\ttag-find [OPTION...] [SELECTOR...]

Selectors:
\t[TAG]    filters tagged files for this tag         ("AND")
\t+[TAG]   adds tagged files to the selection        ("OR")
\t-[TAG]   removes tagged files from the selection   ("NOT")

Options:
\t--help   prints this help text and exits

For issues and documentation: https://github.com/brendanwhitfield/tag-tool
"""




# constructs a find command based on the operations given
# Note: The result of this command will contain several falsely selected
# files, since it will also match substrings of tags.
def build_command(operations):
    flag_str = ""

    for op in operations:
        if op.type == INCLUSION:
            if not flag_str:
                flag_str += " -path *%s*" % op.tag
            else:
                flag_str = "( " + flag_str + " ) -o -path *%s*" % op.tag
        elif op.type == EXCLUSION:
            flag_str += " ! -path *%s*" % op.tag
        elif op.type == INTERSECTION:
            flag_str += " -path *%s*" % op.tag

    # insert the selection flags into the main find command
    return settings.find_cmd % flag_str


# function that uses `find` to retrieve a basic list of files matching
# the given tag selectors.
# Note: see note for build_command()
def find_base_files(operations):

    cmd = build_command(operations)

    # run the find
    try:
        b = subprocess.check_output(cmd.split(), universal_newlines=True)
        return b.split()
    except subprocess.CalledProcessError:
        print("Failed to execute 'find'")
        return []


def match(f, operations):
    tags = get_tags(f)

    matched = True

    # unfortunately, we can't bail on the first unmatched operation
    # since the file can always be included later with `+[TAG]`
    for op in operations:

        if op.type == INTERSECTION:
            if op.tag not in tags:
                matched = False
        else:
            # if the file has the tag for this operation
            if op.tag in tags:
                if op.type == INCLUSION:
                    matched = True
                elif op.type == EXCLUSION:
                    matched = False

    return matched


# function to refine the selection based on the users instructions
# accepts a list of files generated by find_base_files()
def select(operations):
    base_files = find_base_files(operations)
    # can't use filter, since matching function also needs operations
    return [f for f in base_files if match(f, operations)]


def main():
    load_settings()

    operations = []

    for option in sys.argv[1:]:
        if option == "--help":
            print(help_text)
            return
        else:
            if option[0] == "+":
                operations.append(Operation(option[1:], INCLUSION))
            elif option[0] == "-":
                operations.append(Operation(option[1:], EXCLUSION))
            else:
                operations.append(Operation(option, INTERSECTION))

    # check that the user entered something
    if len(operations) == 0:
        print("please give tag selectors")
        return

    # run the selection
    files = select(operations)
    for f in files:
        print(f)


if(__name__ == "__main__"):
    main()
